// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'services.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

FlutterSystemUiOverlayStyle _$FlutterSystemUiOverlayStyleFromJson(
    Map<String, dynamic> json) {
  return _FlutterSystemUiOverlayStyle.fromJson(json);
}

/// @nodoc
mixin _$FlutterSystemUiOverlayStyle {
  FlutterColor? get systemNavigationBarColor =>
      throw _privateConstructorUsedError;
  FlutterColor? get systemNavigationBarDividerColor =>
      throw _privateConstructorUsedError;
  FlutterBrightness? get systemNavigationBarIconBrightness =>
      throw _privateConstructorUsedError;
  ZacBool? get systemNavigationBarContrastEnforced =>
      throw _privateConstructorUsedError;
  FlutterColor? get statusBarColor => throw _privateConstructorUsedError;
  FlutterBrightness? get statusBarBrightness =>
      throw _privateConstructorUsedError;
  FlutterBrightness? get statusBarIconBrightness =>
      throw _privateConstructorUsedError;
  ZacBool? get systemStatusBarContrastEnforced =>
      throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_FlutterSystemUiOverlayStyle value) $default,
  ) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
@JsonSerializable(createToJson: false)
class _$_FlutterSystemUiOverlayStyle extends _FlutterSystemUiOverlayStyle {
  _$_FlutterSystemUiOverlayStyle(
      {this.systemNavigationBarColor,
      this.systemNavigationBarDividerColor,
      this.systemNavigationBarIconBrightness,
      this.systemNavigationBarContrastEnforced,
      this.statusBarColor,
      this.statusBarBrightness,
      this.statusBarIconBrightness,
      this.systemStatusBarContrastEnforced})
      : super._();

  factory _$_FlutterSystemUiOverlayStyle.fromJson(Map<String, dynamic> json) =>
      _$$_FlutterSystemUiOverlayStyleFromJson(json);

  @override
  final FlutterColor? systemNavigationBarColor;
  @override
  final FlutterColor? systemNavigationBarDividerColor;
  @override
  final FlutterBrightness? systemNavigationBarIconBrightness;
  @override
  final ZacBool? systemNavigationBarContrastEnforced;
  @override
  final FlutterColor? statusBarColor;
  @override
  final FlutterBrightness? statusBarBrightness;
  @override
  final FlutterBrightness? statusBarIconBrightness;
  @override
  final ZacBool? systemStatusBarContrastEnforced;

  @override
  String toString() {
    return 'FlutterSystemUiOverlayStyle(systemNavigationBarColor: $systemNavigationBarColor, systemNavigationBarDividerColor: $systemNavigationBarDividerColor, systemNavigationBarIconBrightness: $systemNavigationBarIconBrightness, systemNavigationBarContrastEnforced: $systemNavigationBarContrastEnforced, statusBarColor: $statusBarColor, statusBarBrightness: $statusBarBrightness, statusBarIconBrightness: $statusBarIconBrightness, systemStatusBarContrastEnforced: $systemStatusBarContrastEnforced)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FlutterSystemUiOverlayStyle &&
            const DeepCollectionEquality().equals(
                other.systemNavigationBarColor, systemNavigationBarColor) &&
            const DeepCollectionEquality().equals(
                other.systemNavigationBarDividerColor,
                systemNavigationBarDividerColor) &&
            const DeepCollectionEquality().equals(
                other.systemNavigationBarIconBrightness,
                systemNavigationBarIconBrightness) &&
            const DeepCollectionEquality().equals(
                other.systemNavigationBarContrastEnforced,
                systemNavigationBarContrastEnforced) &&
            const DeepCollectionEquality()
                .equals(other.statusBarColor, statusBarColor) &&
            const DeepCollectionEquality()
                .equals(other.statusBarBrightness, statusBarBrightness) &&
            const DeepCollectionEquality().equals(
                other.statusBarIconBrightness, statusBarIconBrightness) &&
            const DeepCollectionEquality().equals(
                other.systemStatusBarContrastEnforced,
                systemStatusBarContrastEnforced));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(systemNavigationBarColor),
      const DeepCollectionEquality().hash(systemNavigationBarDividerColor),
      const DeepCollectionEquality().hash(systemNavigationBarIconBrightness),
      const DeepCollectionEquality().hash(systemNavigationBarContrastEnforced),
      const DeepCollectionEquality().hash(statusBarColor),
      const DeepCollectionEquality().hash(statusBarBrightness),
      const DeepCollectionEquality().hash(statusBarIconBrightness),
      const DeepCollectionEquality().hash(systemStatusBarContrastEnforced));

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_FlutterSystemUiOverlayStyle value) $default,
  ) {
    return $default(this);
  }
}

abstract class _FlutterSystemUiOverlayStyle
    extends FlutterSystemUiOverlayStyle {
  factory _FlutterSystemUiOverlayStyle(
          {final FlutterColor? systemNavigationBarColor,
          final FlutterColor? systemNavigationBarDividerColor,
          final FlutterBrightness? systemNavigationBarIconBrightness,
          final ZacBool? systemNavigationBarContrastEnforced,
          final FlutterColor? statusBarColor,
          final FlutterBrightness? statusBarBrightness,
          final FlutterBrightness? statusBarIconBrightness,
          final ZacBool? systemStatusBarContrastEnforced}) =
      _$_FlutterSystemUiOverlayStyle;
  _FlutterSystemUiOverlayStyle._() : super._();

  factory _FlutterSystemUiOverlayStyle.fromJson(Map<String, dynamic> json) =
      _$_FlutterSystemUiOverlayStyle.fromJson;

  @override
  FlutterColor? get systemNavigationBarColor;
  @override
  FlutterColor? get systemNavigationBarDividerColor;
  @override
  FlutterBrightness? get systemNavigationBarIconBrightness;
  @override
  ZacBool? get systemNavigationBarContrastEnforced;
  @override
  FlutterColor? get statusBarColor;
  @override
  FlutterBrightness? get statusBarBrightness;
  @override
  FlutterBrightness? get statusBarIconBrightness;
  @override
  ZacBool? get systemStatusBarContrastEnforced;
}

FlutterTextInputType _$FlutterTextInputTypeFromJson(Map<String, dynamic> json) {
  switch (json['_converter']) {
    case 'f:1:TextInputType.datetime':
      return _FlutterTextInputTypedatetime.fromJson(json);
    case 'f:1:TextInputType.emailAddress':
      return _FlutterTextInputTypeemailAddress.fromJson(json);
    case 'f:1:TextInputType.multiline':
      return _FlutterTextInputTypemultiline.fromJson(json);
    case 'f:1:TextInputType.name':
      return _FlutterTextInputTypename.fromJson(json);
    case 'f:1:TextInputType.none':
      return _FlutterTextInputTypenone.fromJson(json);
    case 'f:1:TextInputType.number':
      return _FlutterTextInputTypenumber.fromJson(json);
    case 'f:1:TextInputType.phone':
      return _FlutterTextInputTypephone.fromJson(json);
    case 'f:1:TextInputType.streetAddress':
      return _FlutterTextInputTypestreetAddress.fromJson(json);
    case 'f:1:TextInputType.text':
      return _FlutterTextInputTypetext.fromJson(json);
    case 'f:1:TextInputType.url':
      return _FlutterTextInputTypeurl.fromJson(json);
    case 'f:1:TextInputType.visiblePassword':
      return _FlutterTextInputTypevisiblePassword.fromJson(json);

    default:
      throw CheckedFromJsonException(json, '_converter', 'FlutterTextInputType',
          'Invalid union type "${json['_converter']}"!');
  }
}

/// @nodoc
mixin _$FlutterTextInputType {
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterTextInputTypedatetime value) datetime,
    required TResult Function(_FlutterTextInputTypeemailAddress value)
        emailAddress,
    required TResult Function(_FlutterTextInputTypemultiline value) multiline,
    required TResult Function(_FlutterTextInputTypename value) name,
    required TResult Function(_FlutterTextInputTypenone value) none,
    required TResult Function(_FlutterTextInputTypenumber value) number,
    required TResult Function(_FlutterTextInputTypephone value) phone,
    required TResult Function(_FlutterTextInputTypestreetAddress value)
        streetAddress,
    required TResult Function(_FlutterTextInputTypetext value) text,
    required TResult Function(_FlutterTextInputTypeurl value) url,
    required TResult Function(_FlutterTextInputTypevisiblePassword value)
        visiblePassword,
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
@JsonSerializable(createToJson: false)
class _$_FlutterTextInputTypedatetime extends _FlutterTextInputTypedatetime {
  _$_FlutterTextInputTypedatetime({final String? $type})
      : $type = $type ?? 'f:1:TextInputType.datetime',
        super._();

  factory _$_FlutterTextInputTypedatetime.fromJson(Map<String, dynamic> json) =>
      _$$_FlutterTextInputTypedatetimeFromJson(json);

  @JsonKey(name: '_converter')
  final String $type;

  @override
  String toString() {
    return 'FlutterTextInputType.datetime()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FlutterTextInputTypedatetime);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterTextInputTypedatetime value) datetime,
    required TResult Function(_FlutterTextInputTypeemailAddress value)
        emailAddress,
    required TResult Function(_FlutterTextInputTypemultiline value) multiline,
    required TResult Function(_FlutterTextInputTypename value) name,
    required TResult Function(_FlutterTextInputTypenone value) none,
    required TResult Function(_FlutterTextInputTypenumber value) number,
    required TResult Function(_FlutterTextInputTypephone value) phone,
    required TResult Function(_FlutterTextInputTypestreetAddress value)
        streetAddress,
    required TResult Function(_FlutterTextInputTypetext value) text,
    required TResult Function(_FlutterTextInputTypeurl value) url,
    required TResult Function(_FlutterTextInputTypevisiblePassword value)
        visiblePassword,
  }) {
    return datetime(this);
  }
}

abstract class _FlutterTextInputTypedatetime extends FlutterTextInputType {
  factory _FlutterTextInputTypedatetime() = _$_FlutterTextInputTypedatetime;
  _FlutterTextInputTypedatetime._() : super._();

  factory _FlutterTextInputTypedatetime.fromJson(Map<String, dynamic> json) =
      _$_FlutterTextInputTypedatetime.fromJson;
}

/// @nodoc
@JsonSerializable(createToJson: false)
class _$_FlutterTextInputTypeemailAddress
    extends _FlutterTextInputTypeemailAddress {
  _$_FlutterTextInputTypeemailAddress({final String? $type})
      : $type = $type ?? 'f:1:TextInputType.emailAddress',
        super._();

  factory _$_FlutterTextInputTypeemailAddress.fromJson(
          Map<String, dynamic> json) =>
      _$$_FlutterTextInputTypeemailAddressFromJson(json);

  @JsonKey(name: '_converter')
  final String $type;

  @override
  String toString() {
    return 'FlutterTextInputType.emailAddress()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FlutterTextInputTypeemailAddress);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterTextInputTypedatetime value) datetime,
    required TResult Function(_FlutterTextInputTypeemailAddress value)
        emailAddress,
    required TResult Function(_FlutterTextInputTypemultiline value) multiline,
    required TResult Function(_FlutterTextInputTypename value) name,
    required TResult Function(_FlutterTextInputTypenone value) none,
    required TResult Function(_FlutterTextInputTypenumber value) number,
    required TResult Function(_FlutterTextInputTypephone value) phone,
    required TResult Function(_FlutterTextInputTypestreetAddress value)
        streetAddress,
    required TResult Function(_FlutterTextInputTypetext value) text,
    required TResult Function(_FlutterTextInputTypeurl value) url,
    required TResult Function(_FlutterTextInputTypevisiblePassword value)
        visiblePassword,
  }) {
    return emailAddress(this);
  }
}

abstract class _FlutterTextInputTypeemailAddress extends FlutterTextInputType {
  factory _FlutterTextInputTypeemailAddress() =
      _$_FlutterTextInputTypeemailAddress;
  _FlutterTextInputTypeemailAddress._() : super._();

  factory _FlutterTextInputTypeemailAddress.fromJson(
      Map<String, dynamic> json) = _$_FlutterTextInputTypeemailAddress.fromJson;
}

/// @nodoc
@JsonSerializable(createToJson: false)
class _$_FlutterTextInputTypemultiline extends _FlutterTextInputTypemultiline {
  _$_FlutterTextInputTypemultiline({final String? $type})
      : $type = $type ?? 'f:1:TextInputType.multiline',
        super._();

  factory _$_FlutterTextInputTypemultiline.fromJson(
          Map<String, dynamic> json) =>
      _$$_FlutterTextInputTypemultilineFromJson(json);

  @JsonKey(name: '_converter')
  final String $type;

  @override
  String toString() {
    return 'FlutterTextInputType.multiline()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FlutterTextInputTypemultiline);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterTextInputTypedatetime value) datetime,
    required TResult Function(_FlutterTextInputTypeemailAddress value)
        emailAddress,
    required TResult Function(_FlutterTextInputTypemultiline value) multiline,
    required TResult Function(_FlutterTextInputTypename value) name,
    required TResult Function(_FlutterTextInputTypenone value) none,
    required TResult Function(_FlutterTextInputTypenumber value) number,
    required TResult Function(_FlutterTextInputTypephone value) phone,
    required TResult Function(_FlutterTextInputTypestreetAddress value)
        streetAddress,
    required TResult Function(_FlutterTextInputTypetext value) text,
    required TResult Function(_FlutterTextInputTypeurl value) url,
    required TResult Function(_FlutterTextInputTypevisiblePassword value)
        visiblePassword,
  }) {
    return multiline(this);
  }
}

abstract class _FlutterTextInputTypemultiline extends FlutterTextInputType {
  factory _FlutterTextInputTypemultiline() = _$_FlutterTextInputTypemultiline;
  _FlutterTextInputTypemultiline._() : super._();

  factory _FlutterTextInputTypemultiline.fromJson(Map<String, dynamic> json) =
      _$_FlutterTextInputTypemultiline.fromJson;
}

/// @nodoc
@JsonSerializable(createToJson: false)
class _$_FlutterTextInputTypename extends _FlutterTextInputTypename {
  _$_FlutterTextInputTypename({final String? $type})
      : $type = $type ?? 'f:1:TextInputType.name',
        super._();

  factory _$_FlutterTextInputTypename.fromJson(Map<String, dynamic> json) =>
      _$$_FlutterTextInputTypenameFromJson(json);

  @JsonKey(name: '_converter')
  final String $type;

  @override
  String toString() {
    return 'FlutterTextInputType.name()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FlutterTextInputTypename);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterTextInputTypedatetime value) datetime,
    required TResult Function(_FlutterTextInputTypeemailAddress value)
        emailAddress,
    required TResult Function(_FlutterTextInputTypemultiline value) multiline,
    required TResult Function(_FlutterTextInputTypename value) name,
    required TResult Function(_FlutterTextInputTypenone value) none,
    required TResult Function(_FlutterTextInputTypenumber value) number,
    required TResult Function(_FlutterTextInputTypephone value) phone,
    required TResult Function(_FlutterTextInputTypestreetAddress value)
        streetAddress,
    required TResult Function(_FlutterTextInputTypetext value) text,
    required TResult Function(_FlutterTextInputTypeurl value) url,
    required TResult Function(_FlutterTextInputTypevisiblePassword value)
        visiblePassword,
  }) {
    return name(this);
  }
}

abstract class _FlutterTextInputTypename extends FlutterTextInputType {
  factory _FlutterTextInputTypename() = _$_FlutterTextInputTypename;
  _FlutterTextInputTypename._() : super._();

  factory _FlutterTextInputTypename.fromJson(Map<String, dynamic> json) =
      _$_FlutterTextInputTypename.fromJson;
}

/// @nodoc
@JsonSerializable(createToJson: false)
class _$_FlutterTextInputTypenone extends _FlutterTextInputTypenone {
  _$_FlutterTextInputTypenone({final String? $type})
      : $type = $type ?? 'f:1:TextInputType.none',
        super._();

  factory _$_FlutterTextInputTypenone.fromJson(Map<String, dynamic> json) =>
      _$$_FlutterTextInputTypenoneFromJson(json);

  @JsonKey(name: '_converter')
  final String $type;

  @override
  String toString() {
    return 'FlutterTextInputType.none()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FlutterTextInputTypenone);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterTextInputTypedatetime value) datetime,
    required TResult Function(_FlutterTextInputTypeemailAddress value)
        emailAddress,
    required TResult Function(_FlutterTextInputTypemultiline value) multiline,
    required TResult Function(_FlutterTextInputTypename value) name,
    required TResult Function(_FlutterTextInputTypenone value) none,
    required TResult Function(_FlutterTextInputTypenumber value) number,
    required TResult Function(_FlutterTextInputTypephone value) phone,
    required TResult Function(_FlutterTextInputTypestreetAddress value)
        streetAddress,
    required TResult Function(_FlutterTextInputTypetext value) text,
    required TResult Function(_FlutterTextInputTypeurl value) url,
    required TResult Function(_FlutterTextInputTypevisiblePassword value)
        visiblePassword,
  }) {
    return none(this);
  }
}

abstract class _FlutterTextInputTypenone extends FlutterTextInputType {
  factory _FlutterTextInputTypenone() = _$_FlutterTextInputTypenone;
  _FlutterTextInputTypenone._() : super._();

  factory _FlutterTextInputTypenone.fromJson(Map<String, dynamic> json) =
      _$_FlutterTextInputTypenone.fromJson;
}

/// @nodoc
@JsonSerializable(createToJson: false)
class _$_FlutterTextInputTypenumber extends _FlutterTextInputTypenumber {
  _$_FlutterTextInputTypenumber({final String? $type})
      : $type = $type ?? 'f:1:TextInputType.number',
        super._();

  factory _$_FlutterTextInputTypenumber.fromJson(Map<String, dynamic> json) =>
      _$$_FlutterTextInputTypenumberFromJson(json);

  @JsonKey(name: '_converter')
  final String $type;

  @override
  String toString() {
    return 'FlutterTextInputType.number()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FlutterTextInputTypenumber);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterTextInputTypedatetime value) datetime,
    required TResult Function(_FlutterTextInputTypeemailAddress value)
        emailAddress,
    required TResult Function(_FlutterTextInputTypemultiline value) multiline,
    required TResult Function(_FlutterTextInputTypename value) name,
    required TResult Function(_FlutterTextInputTypenone value) none,
    required TResult Function(_FlutterTextInputTypenumber value) number,
    required TResult Function(_FlutterTextInputTypephone value) phone,
    required TResult Function(_FlutterTextInputTypestreetAddress value)
        streetAddress,
    required TResult Function(_FlutterTextInputTypetext value) text,
    required TResult Function(_FlutterTextInputTypeurl value) url,
    required TResult Function(_FlutterTextInputTypevisiblePassword value)
        visiblePassword,
  }) {
    return number(this);
  }
}

abstract class _FlutterTextInputTypenumber extends FlutterTextInputType {
  factory _FlutterTextInputTypenumber() = _$_FlutterTextInputTypenumber;
  _FlutterTextInputTypenumber._() : super._();

  factory _FlutterTextInputTypenumber.fromJson(Map<String, dynamic> json) =
      _$_FlutterTextInputTypenumber.fromJson;
}

/// @nodoc
@JsonSerializable(createToJson: false)
class _$_FlutterTextInputTypephone extends _FlutterTextInputTypephone {
  _$_FlutterTextInputTypephone({final String? $type})
      : $type = $type ?? 'f:1:TextInputType.phone',
        super._();

  factory _$_FlutterTextInputTypephone.fromJson(Map<String, dynamic> json) =>
      _$$_FlutterTextInputTypephoneFromJson(json);

  @JsonKey(name: '_converter')
  final String $type;

  @override
  String toString() {
    return 'FlutterTextInputType.phone()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FlutterTextInputTypephone);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterTextInputTypedatetime value) datetime,
    required TResult Function(_FlutterTextInputTypeemailAddress value)
        emailAddress,
    required TResult Function(_FlutterTextInputTypemultiline value) multiline,
    required TResult Function(_FlutterTextInputTypename value) name,
    required TResult Function(_FlutterTextInputTypenone value) none,
    required TResult Function(_FlutterTextInputTypenumber value) number,
    required TResult Function(_FlutterTextInputTypephone value) phone,
    required TResult Function(_FlutterTextInputTypestreetAddress value)
        streetAddress,
    required TResult Function(_FlutterTextInputTypetext value) text,
    required TResult Function(_FlutterTextInputTypeurl value) url,
    required TResult Function(_FlutterTextInputTypevisiblePassword value)
        visiblePassword,
  }) {
    return phone(this);
  }
}

abstract class _FlutterTextInputTypephone extends FlutterTextInputType {
  factory _FlutterTextInputTypephone() = _$_FlutterTextInputTypephone;
  _FlutterTextInputTypephone._() : super._();

  factory _FlutterTextInputTypephone.fromJson(Map<String, dynamic> json) =
      _$_FlutterTextInputTypephone.fromJson;
}

/// @nodoc
@JsonSerializable(createToJson: false)
class _$_FlutterTextInputTypestreetAddress
    extends _FlutterTextInputTypestreetAddress {
  _$_FlutterTextInputTypestreetAddress({final String? $type})
      : $type = $type ?? 'f:1:TextInputType.streetAddress',
        super._();

  factory _$_FlutterTextInputTypestreetAddress.fromJson(
          Map<String, dynamic> json) =>
      _$$_FlutterTextInputTypestreetAddressFromJson(json);

  @JsonKey(name: '_converter')
  final String $type;

  @override
  String toString() {
    return 'FlutterTextInputType.streetAddress()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FlutterTextInputTypestreetAddress);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterTextInputTypedatetime value) datetime,
    required TResult Function(_FlutterTextInputTypeemailAddress value)
        emailAddress,
    required TResult Function(_FlutterTextInputTypemultiline value) multiline,
    required TResult Function(_FlutterTextInputTypename value) name,
    required TResult Function(_FlutterTextInputTypenone value) none,
    required TResult Function(_FlutterTextInputTypenumber value) number,
    required TResult Function(_FlutterTextInputTypephone value) phone,
    required TResult Function(_FlutterTextInputTypestreetAddress value)
        streetAddress,
    required TResult Function(_FlutterTextInputTypetext value) text,
    required TResult Function(_FlutterTextInputTypeurl value) url,
    required TResult Function(_FlutterTextInputTypevisiblePassword value)
        visiblePassword,
  }) {
    return streetAddress(this);
  }
}

abstract class _FlutterTextInputTypestreetAddress extends FlutterTextInputType {
  factory _FlutterTextInputTypestreetAddress() =
      _$_FlutterTextInputTypestreetAddress;
  _FlutterTextInputTypestreetAddress._() : super._();

  factory _FlutterTextInputTypestreetAddress.fromJson(
          Map<String, dynamic> json) =
      _$_FlutterTextInputTypestreetAddress.fromJson;
}

/// @nodoc
@JsonSerializable(createToJson: false)
class _$_FlutterTextInputTypetext extends _FlutterTextInputTypetext {
  _$_FlutterTextInputTypetext({final String? $type})
      : $type = $type ?? 'f:1:TextInputType.text',
        super._();

  factory _$_FlutterTextInputTypetext.fromJson(Map<String, dynamic> json) =>
      _$$_FlutterTextInputTypetextFromJson(json);

  @JsonKey(name: '_converter')
  final String $type;

  @override
  String toString() {
    return 'FlutterTextInputType.text()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FlutterTextInputTypetext);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterTextInputTypedatetime value) datetime,
    required TResult Function(_FlutterTextInputTypeemailAddress value)
        emailAddress,
    required TResult Function(_FlutterTextInputTypemultiline value) multiline,
    required TResult Function(_FlutterTextInputTypename value) name,
    required TResult Function(_FlutterTextInputTypenone value) none,
    required TResult Function(_FlutterTextInputTypenumber value) number,
    required TResult Function(_FlutterTextInputTypephone value) phone,
    required TResult Function(_FlutterTextInputTypestreetAddress value)
        streetAddress,
    required TResult Function(_FlutterTextInputTypetext value) text,
    required TResult Function(_FlutterTextInputTypeurl value) url,
    required TResult Function(_FlutterTextInputTypevisiblePassword value)
        visiblePassword,
  }) {
    return text(this);
  }
}

abstract class _FlutterTextInputTypetext extends FlutterTextInputType {
  factory _FlutterTextInputTypetext() = _$_FlutterTextInputTypetext;
  _FlutterTextInputTypetext._() : super._();

  factory _FlutterTextInputTypetext.fromJson(Map<String, dynamic> json) =
      _$_FlutterTextInputTypetext.fromJson;
}

/// @nodoc
@JsonSerializable(createToJson: false)
class _$_FlutterTextInputTypeurl extends _FlutterTextInputTypeurl {
  _$_FlutterTextInputTypeurl({final String? $type})
      : $type = $type ?? 'f:1:TextInputType.url',
        super._();

  factory _$_FlutterTextInputTypeurl.fromJson(Map<String, dynamic> json) =>
      _$$_FlutterTextInputTypeurlFromJson(json);

  @JsonKey(name: '_converter')
  final String $type;

  @override
  String toString() {
    return 'FlutterTextInputType.url()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FlutterTextInputTypeurl);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterTextInputTypedatetime value) datetime,
    required TResult Function(_FlutterTextInputTypeemailAddress value)
        emailAddress,
    required TResult Function(_FlutterTextInputTypemultiline value) multiline,
    required TResult Function(_FlutterTextInputTypename value) name,
    required TResult Function(_FlutterTextInputTypenone value) none,
    required TResult Function(_FlutterTextInputTypenumber value) number,
    required TResult Function(_FlutterTextInputTypephone value) phone,
    required TResult Function(_FlutterTextInputTypestreetAddress value)
        streetAddress,
    required TResult Function(_FlutterTextInputTypetext value) text,
    required TResult Function(_FlutterTextInputTypeurl value) url,
    required TResult Function(_FlutterTextInputTypevisiblePassword value)
        visiblePassword,
  }) {
    return url(this);
  }
}

abstract class _FlutterTextInputTypeurl extends FlutterTextInputType {
  factory _FlutterTextInputTypeurl() = _$_FlutterTextInputTypeurl;
  _FlutterTextInputTypeurl._() : super._();

  factory _FlutterTextInputTypeurl.fromJson(Map<String, dynamic> json) =
      _$_FlutterTextInputTypeurl.fromJson;
}

/// @nodoc
@JsonSerializable(createToJson: false)
class _$_FlutterTextInputTypevisiblePassword
    extends _FlutterTextInputTypevisiblePassword {
  _$_FlutterTextInputTypevisiblePassword({final String? $type})
      : $type = $type ?? 'f:1:TextInputType.visiblePassword',
        super._();

  factory _$_FlutterTextInputTypevisiblePassword.fromJson(
          Map<String, dynamic> json) =>
      _$$_FlutterTextInputTypevisiblePasswordFromJson(json);

  @JsonKey(name: '_converter')
  final String $type;

  @override
  String toString() {
    return 'FlutterTextInputType.visiblePassword()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FlutterTextInputTypevisiblePassword);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterTextInputTypedatetime value) datetime,
    required TResult Function(_FlutterTextInputTypeemailAddress value)
        emailAddress,
    required TResult Function(_FlutterTextInputTypemultiline value) multiline,
    required TResult Function(_FlutterTextInputTypename value) name,
    required TResult Function(_FlutterTextInputTypenone value) none,
    required TResult Function(_FlutterTextInputTypenumber value) number,
    required TResult Function(_FlutterTextInputTypephone value) phone,
    required TResult Function(_FlutterTextInputTypestreetAddress value)
        streetAddress,
    required TResult Function(_FlutterTextInputTypetext value) text,
    required TResult Function(_FlutterTextInputTypeurl value) url,
    required TResult Function(_FlutterTextInputTypevisiblePassword value)
        visiblePassword,
  }) {
    return visiblePassword(this);
  }
}

abstract class _FlutterTextInputTypevisiblePassword
    extends FlutterTextInputType {
  factory _FlutterTextInputTypevisiblePassword() =
      _$_FlutterTextInputTypevisiblePassword;
  _FlutterTextInputTypevisiblePassword._() : super._();

  factory _FlutterTextInputTypevisiblePassword.fromJson(
          Map<String, dynamic> json) =
      _$_FlutterTextInputTypevisiblePassword.fromJson;
}

FlutterTextInputAction _$FlutterTextInputActionFromJson(
    Map<String, dynamic> json) {
  switch (json['_converter']) {
    case 'f:1:TextInputAction.continueAction':
      return _FlutterTextInputActioncontinueAction.fromJson(json);
    case 'f:1:TextInputAction.done':
      return _FlutterTextInputActiondone.fromJson(json);
    case 'f:1:TextInputAction.emergencyCall':
      return _FlutterTextInputActionemergencyCall.fromJson(json);
    case 'f:1:TextInputAction.go':
      return _FlutterTextInputActiongo.fromJson(json);
    case 'f:1:TextInputAction.join':
      return _FlutterTextInputActionjoin.fromJson(json);
    case 'f:1:TextInputAction.newline':
      return _FlutterTextInputActionnewline.fromJson(json);
    case 'f:1:TextInputAction.next':
      return _FlutterTextInputActionnext.fromJson(json);
    case 'f:1:TextInputAction.none':
      return _FlutterTextInputActionnone.fromJson(json);
    case 'f:1:TextInputAction.previous':
      return _FlutterTextInputActionprevious.fromJson(json);
    case 'f:1:TextInputAction.route':
      return _FlutterTextInputActionroute.fromJson(json);
    case 'f:1:TextInputAction.search':
      return _FlutterTextInputActionsearch.fromJson(json);
    case 'f:1:TextInputAction.send':
      return _FlutterTextInputActionsend.fromJson(json);
    case 'f:1:TextInputAction.unspecified':
      return _FlutterTextInputActionunspecified.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          '_converter',
          'FlutterTextInputAction',
          'Invalid union type "${json['_converter']}"!');
  }
}

/// @nodoc
mixin _$FlutterTextInputAction {
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterTextInputActioncontinueAction value)
        continueAction,
    required TResult Function(_FlutterTextInputActiondone value) done,
    required TResult Function(_FlutterTextInputActionemergencyCall value)
        emergencyCall,
    required TResult Function(_FlutterTextInputActiongo value) go,
    required TResult Function(_FlutterTextInputActionjoin value) join,
    required TResult Function(_FlutterTextInputActionnewline value) newline,
    required TResult Function(_FlutterTextInputActionnext value) next,
    required TResult Function(_FlutterTextInputActionnone value) none,
    required TResult Function(_FlutterTextInputActionprevious value) previous,
    required TResult Function(_FlutterTextInputActionroute value) route,
    required TResult Function(_FlutterTextInputActionsearch value) search,
    required TResult Function(_FlutterTextInputActionsend value) send,
    required TResult Function(_FlutterTextInputActionunspecified value)
        unspecified,
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
@JsonSerializable(createToJson: false)
class _$_FlutterTextInputActioncontinueAction
    extends _FlutterTextInputActioncontinueAction {
  _$_FlutterTextInputActioncontinueAction({final String? $type})
      : $type = $type ?? 'f:1:TextInputAction.continueAction',
        super._();

  factory _$_FlutterTextInputActioncontinueAction.fromJson(
          Map<String, dynamic> json) =>
      _$$_FlutterTextInputActioncontinueActionFromJson(json);

  @JsonKey(name: '_converter')
  final String $type;

  @override
  String toString() {
    return 'FlutterTextInputAction.continueAction()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FlutterTextInputActioncontinueAction);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterTextInputActioncontinueAction value)
        continueAction,
    required TResult Function(_FlutterTextInputActiondone value) done,
    required TResult Function(_FlutterTextInputActionemergencyCall value)
        emergencyCall,
    required TResult Function(_FlutterTextInputActiongo value) go,
    required TResult Function(_FlutterTextInputActionjoin value) join,
    required TResult Function(_FlutterTextInputActionnewline value) newline,
    required TResult Function(_FlutterTextInputActionnext value) next,
    required TResult Function(_FlutterTextInputActionnone value) none,
    required TResult Function(_FlutterTextInputActionprevious value) previous,
    required TResult Function(_FlutterTextInputActionroute value) route,
    required TResult Function(_FlutterTextInputActionsearch value) search,
    required TResult Function(_FlutterTextInputActionsend value) send,
    required TResult Function(_FlutterTextInputActionunspecified value)
        unspecified,
  }) {
    return continueAction(this);
  }
}

abstract class _FlutterTextInputActioncontinueAction
    extends FlutterTextInputAction {
  factory _FlutterTextInputActioncontinueAction() =
      _$_FlutterTextInputActioncontinueAction;
  _FlutterTextInputActioncontinueAction._() : super._();

  factory _FlutterTextInputActioncontinueAction.fromJson(
          Map<String, dynamic> json) =
      _$_FlutterTextInputActioncontinueAction.fromJson;
}

/// @nodoc
@JsonSerializable(createToJson: false)
class _$_FlutterTextInputActiondone extends _FlutterTextInputActiondone {
  _$_FlutterTextInputActiondone({final String? $type})
      : $type = $type ?? 'f:1:TextInputAction.done',
        super._();

  factory _$_FlutterTextInputActiondone.fromJson(Map<String, dynamic> json) =>
      _$$_FlutterTextInputActiondoneFromJson(json);

  @JsonKey(name: '_converter')
  final String $type;

  @override
  String toString() {
    return 'FlutterTextInputAction.done()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FlutterTextInputActiondone);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterTextInputActioncontinueAction value)
        continueAction,
    required TResult Function(_FlutterTextInputActiondone value) done,
    required TResult Function(_FlutterTextInputActionemergencyCall value)
        emergencyCall,
    required TResult Function(_FlutterTextInputActiongo value) go,
    required TResult Function(_FlutterTextInputActionjoin value) join,
    required TResult Function(_FlutterTextInputActionnewline value) newline,
    required TResult Function(_FlutterTextInputActionnext value) next,
    required TResult Function(_FlutterTextInputActionnone value) none,
    required TResult Function(_FlutterTextInputActionprevious value) previous,
    required TResult Function(_FlutterTextInputActionroute value) route,
    required TResult Function(_FlutterTextInputActionsearch value) search,
    required TResult Function(_FlutterTextInputActionsend value) send,
    required TResult Function(_FlutterTextInputActionunspecified value)
        unspecified,
  }) {
    return done(this);
  }
}

abstract class _FlutterTextInputActiondone extends FlutterTextInputAction {
  factory _FlutterTextInputActiondone() = _$_FlutterTextInputActiondone;
  _FlutterTextInputActiondone._() : super._();

  factory _FlutterTextInputActiondone.fromJson(Map<String, dynamic> json) =
      _$_FlutterTextInputActiondone.fromJson;
}

/// @nodoc
@JsonSerializable(createToJson: false)
class _$_FlutterTextInputActionemergencyCall
    extends _FlutterTextInputActionemergencyCall {
  _$_FlutterTextInputActionemergencyCall({final String? $type})
      : $type = $type ?? 'f:1:TextInputAction.emergencyCall',
        super._();

  factory _$_FlutterTextInputActionemergencyCall.fromJson(
          Map<String, dynamic> json) =>
      _$$_FlutterTextInputActionemergencyCallFromJson(json);

  @JsonKey(name: '_converter')
  final String $type;

  @override
  String toString() {
    return 'FlutterTextInputAction.emergencyCall()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FlutterTextInputActionemergencyCall);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterTextInputActioncontinueAction value)
        continueAction,
    required TResult Function(_FlutterTextInputActiondone value) done,
    required TResult Function(_FlutterTextInputActionemergencyCall value)
        emergencyCall,
    required TResult Function(_FlutterTextInputActiongo value) go,
    required TResult Function(_FlutterTextInputActionjoin value) join,
    required TResult Function(_FlutterTextInputActionnewline value) newline,
    required TResult Function(_FlutterTextInputActionnext value) next,
    required TResult Function(_FlutterTextInputActionnone value) none,
    required TResult Function(_FlutterTextInputActionprevious value) previous,
    required TResult Function(_FlutterTextInputActionroute value) route,
    required TResult Function(_FlutterTextInputActionsearch value) search,
    required TResult Function(_FlutterTextInputActionsend value) send,
    required TResult Function(_FlutterTextInputActionunspecified value)
        unspecified,
  }) {
    return emergencyCall(this);
  }
}

abstract class _FlutterTextInputActionemergencyCall
    extends FlutterTextInputAction {
  factory _FlutterTextInputActionemergencyCall() =
      _$_FlutterTextInputActionemergencyCall;
  _FlutterTextInputActionemergencyCall._() : super._();

  factory _FlutterTextInputActionemergencyCall.fromJson(
          Map<String, dynamic> json) =
      _$_FlutterTextInputActionemergencyCall.fromJson;
}

/// @nodoc
@JsonSerializable(createToJson: false)
class _$_FlutterTextInputActiongo extends _FlutterTextInputActiongo {
  _$_FlutterTextInputActiongo({final String? $type})
      : $type = $type ?? 'f:1:TextInputAction.go',
        super._();

  factory _$_FlutterTextInputActiongo.fromJson(Map<String, dynamic> json) =>
      _$$_FlutterTextInputActiongoFromJson(json);

  @JsonKey(name: '_converter')
  final String $type;

  @override
  String toString() {
    return 'FlutterTextInputAction.go()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FlutterTextInputActiongo);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterTextInputActioncontinueAction value)
        continueAction,
    required TResult Function(_FlutterTextInputActiondone value) done,
    required TResult Function(_FlutterTextInputActionemergencyCall value)
        emergencyCall,
    required TResult Function(_FlutterTextInputActiongo value) go,
    required TResult Function(_FlutterTextInputActionjoin value) join,
    required TResult Function(_FlutterTextInputActionnewline value) newline,
    required TResult Function(_FlutterTextInputActionnext value) next,
    required TResult Function(_FlutterTextInputActionnone value) none,
    required TResult Function(_FlutterTextInputActionprevious value) previous,
    required TResult Function(_FlutterTextInputActionroute value) route,
    required TResult Function(_FlutterTextInputActionsearch value) search,
    required TResult Function(_FlutterTextInputActionsend value) send,
    required TResult Function(_FlutterTextInputActionunspecified value)
        unspecified,
  }) {
    return go(this);
  }
}

abstract class _FlutterTextInputActiongo extends FlutterTextInputAction {
  factory _FlutterTextInputActiongo() = _$_FlutterTextInputActiongo;
  _FlutterTextInputActiongo._() : super._();

  factory _FlutterTextInputActiongo.fromJson(Map<String, dynamic> json) =
      _$_FlutterTextInputActiongo.fromJson;
}

/// @nodoc
@JsonSerializable(createToJson: false)
class _$_FlutterTextInputActionjoin extends _FlutterTextInputActionjoin {
  _$_FlutterTextInputActionjoin({final String? $type})
      : $type = $type ?? 'f:1:TextInputAction.join',
        super._();

  factory _$_FlutterTextInputActionjoin.fromJson(Map<String, dynamic> json) =>
      _$$_FlutterTextInputActionjoinFromJson(json);

  @JsonKey(name: '_converter')
  final String $type;

  @override
  String toString() {
    return 'FlutterTextInputAction.join()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FlutterTextInputActionjoin);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterTextInputActioncontinueAction value)
        continueAction,
    required TResult Function(_FlutterTextInputActiondone value) done,
    required TResult Function(_FlutterTextInputActionemergencyCall value)
        emergencyCall,
    required TResult Function(_FlutterTextInputActiongo value) go,
    required TResult Function(_FlutterTextInputActionjoin value) join,
    required TResult Function(_FlutterTextInputActionnewline value) newline,
    required TResult Function(_FlutterTextInputActionnext value) next,
    required TResult Function(_FlutterTextInputActionnone value) none,
    required TResult Function(_FlutterTextInputActionprevious value) previous,
    required TResult Function(_FlutterTextInputActionroute value) route,
    required TResult Function(_FlutterTextInputActionsearch value) search,
    required TResult Function(_FlutterTextInputActionsend value) send,
    required TResult Function(_FlutterTextInputActionunspecified value)
        unspecified,
  }) {
    return join(this);
  }
}

abstract class _FlutterTextInputActionjoin extends FlutterTextInputAction {
  factory _FlutterTextInputActionjoin() = _$_FlutterTextInputActionjoin;
  _FlutterTextInputActionjoin._() : super._();

  factory _FlutterTextInputActionjoin.fromJson(Map<String, dynamic> json) =
      _$_FlutterTextInputActionjoin.fromJson;
}

/// @nodoc
@JsonSerializable(createToJson: false)
class _$_FlutterTextInputActionnewline extends _FlutterTextInputActionnewline {
  _$_FlutterTextInputActionnewline({final String? $type})
      : $type = $type ?? 'f:1:TextInputAction.newline',
        super._();

  factory _$_FlutterTextInputActionnewline.fromJson(
          Map<String, dynamic> json) =>
      _$$_FlutterTextInputActionnewlineFromJson(json);

  @JsonKey(name: '_converter')
  final String $type;

  @override
  String toString() {
    return 'FlutterTextInputAction.newline()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FlutterTextInputActionnewline);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterTextInputActioncontinueAction value)
        continueAction,
    required TResult Function(_FlutterTextInputActiondone value) done,
    required TResult Function(_FlutterTextInputActionemergencyCall value)
        emergencyCall,
    required TResult Function(_FlutterTextInputActiongo value) go,
    required TResult Function(_FlutterTextInputActionjoin value) join,
    required TResult Function(_FlutterTextInputActionnewline value) newline,
    required TResult Function(_FlutterTextInputActionnext value) next,
    required TResult Function(_FlutterTextInputActionnone value) none,
    required TResult Function(_FlutterTextInputActionprevious value) previous,
    required TResult Function(_FlutterTextInputActionroute value) route,
    required TResult Function(_FlutterTextInputActionsearch value) search,
    required TResult Function(_FlutterTextInputActionsend value) send,
    required TResult Function(_FlutterTextInputActionunspecified value)
        unspecified,
  }) {
    return newline(this);
  }
}

abstract class _FlutterTextInputActionnewline extends FlutterTextInputAction {
  factory _FlutterTextInputActionnewline() = _$_FlutterTextInputActionnewline;
  _FlutterTextInputActionnewline._() : super._();

  factory _FlutterTextInputActionnewline.fromJson(Map<String, dynamic> json) =
      _$_FlutterTextInputActionnewline.fromJson;
}

/// @nodoc
@JsonSerializable(createToJson: false)
class _$_FlutterTextInputActionnext extends _FlutterTextInputActionnext {
  _$_FlutterTextInputActionnext({final String? $type})
      : $type = $type ?? 'f:1:TextInputAction.next',
        super._();

  factory _$_FlutterTextInputActionnext.fromJson(Map<String, dynamic> json) =>
      _$$_FlutterTextInputActionnextFromJson(json);

  @JsonKey(name: '_converter')
  final String $type;

  @override
  String toString() {
    return 'FlutterTextInputAction.next()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FlutterTextInputActionnext);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterTextInputActioncontinueAction value)
        continueAction,
    required TResult Function(_FlutterTextInputActiondone value) done,
    required TResult Function(_FlutterTextInputActionemergencyCall value)
        emergencyCall,
    required TResult Function(_FlutterTextInputActiongo value) go,
    required TResult Function(_FlutterTextInputActionjoin value) join,
    required TResult Function(_FlutterTextInputActionnewline value) newline,
    required TResult Function(_FlutterTextInputActionnext value) next,
    required TResult Function(_FlutterTextInputActionnone value) none,
    required TResult Function(_FlutterTextInputActionprevious value) previous,
    required TResult Function(_FlutterTextInputActionroute value) route,
    required TResult Function(_FlutterTextInputActionsearch value) search,
    required TResult Function(_FlutterTextInputActionsend value) send,
    required TResult Function(_FlutterTextInputActionunspecified value)
        unspecified,
  }) {
    return next(this);
  }
}

abstract class _FlutterTextInputActionnext extends FlutterTextInputAction {
  factory _FlutterTextInputActionnext() = _$_FlutterTextInputActionnext;
  _FlutterTextInputActionnext._() : super._();

  factory _FlutterTextInputActionnext.fromJson(Map<String, dynamic> json) =
      _$_FlutterTextInputActionnext.fromJson;
}

/// @nodoc
@JsonSerializable(createToJson: false)
class _$_FlutterTextInputActionnone extends _FlutterTextInputActionnone {
  _$_FlutterTextInputActionnone({final String? $type})
      : $type = $type ?? 'f:1:TextInputAction.none',
        super._();

  factory _$_FlutterTextInputActionnone.fromJson(Map<String, dynamic> json) =>
      _$$_FlutterTextInputActionnoneFromJson(json);

  @JsonKey(name: '_converter')
  final String $type;

  @override
  String toString() {
    return 'FlutterTextInputAction.none()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FlutterTextInputActionnone);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterTextInputActioncontinueAction value)
        continueAction,
    required TResult Function(_FlutterTextInputActiondone value) done,
    required TResult Function(_FlutterTextInputActionemergencyCall value)
        emergencyCall,
    required TResult Function(_FlutterTextInputActiongo value) go,
    required TResult Function(_FlutterTextInputActionjoin value) join,
    required TResult Function(_FlutterTextInputActionnewline value) newline,
    required TResult Function(_FlutterTextInputActionnext value) next,
    required TResult Function(_FlutterTextInputActionnone value) none,
    required TResult Function(_FlutterTextInputActionprevious value) previous,
    required TResult Function(_FlutterTextInputActionroute value) route,
    required TResult Function(_FlutterTextInputActionsearch value) search,
    required TResult Function(_FlutterTextInputActionsend value) send,
    required TResult Function(_FlutterTextInputActionunspecified value)
        unspecified,
  }) {
    return none(this);
  }
}

abstract class _FlutterTextInputActionnone extends FlutterTextInputAction {
  factory _FlutterTextInputActionnone() = _$_FlutterTextInputActionnone;
  _FlutterTextInputActionnone._() : super._();

  factory _FlutterTextInputActionnone.fromJson(Map<String, dynamic> json) =
      _$_FlutterTextInputActionnone.fromJson;
}

/// @nodoc
@JsonSerializable(createToJson: false)
class _$_FlutterTextInputActionprevious
    extends _FlutterTextInputActionprevious {
  _$_FlutterTextInputActionprevious({final String? $type})
      : $type = $type ?? 'f:1:TextInputAction.previous',
        super._();

  factory _$_FlutterTextInputActionprevious.fromJson(
          Map<String, dynamic> json) =>
      _$$_FlutterTextInputActionpreviousFromJson(json);

  @JsonKey(name: '_converter')
  final String $type;

  @override
  String toString() {
    return 'FlutterTextInputAction.previous()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FlutterTextInputActionprevious);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterTextInputActioncontinueAction value)
        continueAction,
    required TResult Function(_FlutterTextInputActiondone value) done,
    required TResult Function(_FlutterTextInputActionemergencyCall value)
        emergencyCall,
    required TResult Function(_FlutterTextInputActiongo value) go,
    required TResult Function(_FlutterTextInputActionjoin value) join,
    required TResult Function(_FlutterTextInputActionnewline value) newline,
    required TResult Function(_FlutterTextInputActionnext value) next,
    required TResult Function(_FlutterTextInputActionnone value) none,
    required TResult Function(_FlutterTextInputActionprevious value) previous,
    required TResult Function(_FlutterTextInputActionroute value) route,
    required TResult Function(_FlutterTextInputActionsearch value) search,
    required TResult Function(_FlutterTextInputActionsend value) send,
    required TResult Function(_FlutterTextInputActionunspecified value)
        unspecified,
  }) {
    return previous(this);
  }
}

abstract class _FlutterTextInputActionprevious extends FlutterTextInputAction {
  factory _FlutterTextInputActionprevious() = _$_FlutterTextInputActionprevious;
  _FlutterTextInputActionprevious._() : super._();

  factory _FlutterTextInputActionprevious.fromJson(Map<String, dynamic> json) =
      _$_FlutterTextInputActionprevious.fromJson;
}

/// @nodoc
@JsonSerializable(createToJson: false)
class _$_FlutterTextInputActionroute extends _FlutterTextInputActionroute {
  _$_FlutterTextInputActionroute({final String? $type})
      : $type = $type ?? 'f:1:TextInputAction.route',
        super._();

  factory _$_FlutterTextInputActionroute.fromJson(Map<String, dynamic> json) =>
      _$$_FlutterTextInputActionrouteFromJson(json);

  @JsonKey(name: '_converter')
  final String $type;

  @override
  String toString() {
    return 'FlutterTextInputAction.route()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FlutterTextInputActionroute);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterTextInputActioncontinueAction value)
        continueAction,
    required TResult Function(_FlutterTextInputActiondone value) done,
    required TResult Function(_FlutterTextInputActionemergencyCall value)
        emergencyCall,
    required TResult Function(_FlutterTextInputActiongo value) go,
    required TResult Function(_FlutterTextInputActionjoin value) join,
    required TResult Function(_FlutterTextInputActionnewline value) newline,
    required TResult Function(_FlutterTextInputActionnext value) next,
    required TResult Function(_FlutterTextInputActionnone value) none,
    required TResult Function(_FlutterTextInputActionprevious value) previous,
    required TResult Function(_FlutterTextInputActionroute value) route,
    required TResult Function(_FlutterTextInputActionsearch value) search,
    required TResult Function(_FlutterTextInputActionsend value) send,
    required TResult Function(_FlutterTextInputActionunspecified value)
        unspecified,
  }) {
    return route(this);
  }
}

abstract class _FlutterTextInputActionroute extends FlutterTextInputAction {
  factory _FlutterTextInputActionroute() = _$_FlutterTextInputActionroute;
  _FlutterTextInputActionroute._() : super._();

  factory _FlutterTextInputActionroute.fromJson(Map<String, dynamic> json) =
      _$_FlutterTextInputActionroute.fromJson;
}

/// @nodoc
@JsonSerializable(createToJson: false)
class _$_FlutterTextInputActionsearch extends _FlutterTextInputActionsearch {
  _$_FlutterTextInputActionsearch({final String? $type})
      : $type = $type ?? 'f:1:TextInputAction.search',
        super._();

  factory _$_FlutterTextInputActionsearch.fromJson(Map<String, dynamic> json) =>
      _$$_FlutterTextInputActionsearchFromJson(json);

  @JsonKey(name: '_converter')
  final String $type;

  @override
  String toString() {
    return 'FlutterTextInputAction.search()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FlutterTextInputActionsearch);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterTextInputActioncontinueAction value)
        continueAction,
    required TResult Function(_FlutterTextInputActiondone value) done,
    required TResult Function(_FlutterTextInputActionemergencyCall value)
        emergencyCall,
    required TResult Function(_FlutterTextInputActiongo value) go,
    required TResult Function(_FlutterTextInputActionjoin value) join,
    required TResult Function(_FlutterTextInputActionnewline value) newline,
    required TResult Function(_FlutterTextInputActionnext value) next,
    required TResult Function(_FlutterTextInputActionnone value) none,
    required TResult Function(_FlutterTextInputActionprevious value) previous,
    required TResult Function(_FlutterTextInputActionroute value) route,
    required TResult Function(_FlutterTextInputActionsearch value) search,
    required TResult Function(_FlutterTextInputActionsend value) send,
    required TResult Function(_FlutterTextInputActionunspecified value)
        unspecified,
  }) {
    return search(this);
  }
}

abstract class _FlutterTextInputActionsearch extends FlutterTextInputAction {
  factory _FlutterTextInputActionsearch() = _$_FlutterTextInputActionsearch;
  _FlutterTextInputActionsearch._() : super._();

  factory _FlutterTextInputActionsearch.fromJson(Map<String, dynamic> json) =
      _$_FlutterTextInputActionsearch.fromJson;
}

/// @nodoc
@JsonSerializable(createToJson: false)
class _$_FlutterTextInputActionsend extends _FlutterTextInputActionsend {
  _$_FlutterTextInputActionsend({final String? $type})
      : $type = $type ?? 'f:1:TextInputAction.send',
        super._();

  factory _$_FlutterTextInputActionsend.fromJson(Map<String, dynamic> json) =>
      _$$_FlutterTextInputActionsendFromJson(json);

  @JsonKey(name: '_converter')
  final String $type;

  @override
  String toString() {
    return 'FlutterTextInputAction.send()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FlutterTextInputActionsend);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterTextInputActioncontinueAction value)
        continueAction,
    required TResult Function(_FlutterTextInputActiondone value) done,
    required TResult Function(_FlutterTextInputActionemergencyCall value)
        emergencyCall,
    required TResult Function(_FlutterTextInputActiongo value) go,
    required TResult Function(_FlutterTextInputActionjoin value) join,
    required TResult Function(_FlutterTextInputActionnewline value) newline,
    required TResult Function(_FlutterTextInputActionnext value) next,
    required TResult Function(_FlutterTextInputActionnone value) none,
    required TResult Function(_FlutterTextInputActionprevious value) previous,
    required TResult Function(_FlutterTextInputActionroute value) route,
    required TResult Function(_FlutterTextInputActionsearch value) search,
    required TResult Function(_FlutterTextInputActionsend value) send,
    required TResult Function(_FlutterTextInputActionunspecified value)
        unspecified,
  }) {
    return send(this);
  }
}

abstract class _FlutterTextInputActionsend extends FlutterTextInputAction {
  factory _FlutterTextInputActionsend() = _$_FlutterTextInputActionsend;
  _FlutterTextInputActionsend._() : super._();

  factory _FlutterTextInputActionsend.fromJson(Map<String, dynamic> json) =
      _$_FlutterTextInputActionsend.fromJson;
}

/// @nodoc
@JsonSerializable(createToJson: false)
class _$_FlutterTextInputActionunspecified
    extends _FlutterTextInputActionunspecified {
  _$_FlutterTextInputActionunspecified({final String? $type})
      : $type = $type ?? 'f:1:TextInputAction.unspecified',
        super._();

  factory _$_FlutterTextInputActionunspecified.fromJson(
          Map<String, dynamic> json) =>
      _$$_FlutterTextInputActionunspecifiedFromJson(json);

  @JsonKey(name: '_converter')
  final String $type;

  @override
  String toString() {
    return 'FlutterTextInputAction.unspecified()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FlutterTextInputActionunspecified);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterTextInputActioncontinueAction value)
        continueAction,
    required TResult Function(_FlutterTextInputActiondone value) done,
    required TResult Function(_FlutterTextInputActionemergencyCall value)
        emergencyCall,
    required TResult Function(_FlutterTextInputActiongo value) go,
    required TResult Function(_FlutterTextInputActionjoin value) join,
    required TResult Function(_FlutterTextInputActionnewline value) newline,
    required TResult Function(_FlutterTextInputActionnext value) next,
    required TResult Function(_FlutterTextInputActionnone value) none,
    required TResult Function(_FlutterTextInputActionprevious value) previous,
    required TResult Function(_FlutterTextInputActionroute value) route,
    required TResult Function(_FlutterTextInputActionsearch value) search,
    required TResult Function(_FlutterTextInputActionsend value) send,
    required TResult Function(_FlutterTextInputActionunspecified value)
        unspecified,
  }) {
    return unspecified(this);
  }
}

abstract class _FlutterTextInputActionunspecified
    extends FlutterTextInputAction {
  factory _FlutterTextInputActionunspecified() =
      _$_FlutterTextInputActionunspecified;
  _FlutterTextInputActionunspecified._() : super._();

  factory _FlutterTextInputActionunspecified.fromJson(
          Map<String, dynamic> json) =
      _$_FlutterTextInputActionunspecified.fromJson;
}

FlutterTextCapitalization _$FlutterTextCapitalizationFromJson(
    Map<String, dynamic> json) {
  switch (json['_converter']) {
    case 'f:1:TextCapitalization.characters':
      return _FlutterTextCapitalizationcharacters.fromJson(json);
    case 'f:1:TextCapitalization.none':
      return _FlutterTextCapitalizationnone.fromJson(json);
    case 'f:1:TextCapitalization.sentences':
      return _FlutterTextCapitalizationsentences.fromJson(json);
    case 'f:1:TextCapitalization.words':
      return _FlutterTextCapitalizationwords.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          '_converter',
          'FlutterTextCapitalization',
          'Invalid union type "${json['_converter']}"!');
  }
}

/// @nodoc
mixin _$FlutterTextCapitalization {
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterTextCapitalizationcharacters value)
        characters,
    required TResult Function(_FlutterTextCapitalizationnone value) none,
    required TResult Function(_FlutterTextCapitalizationsentences value)
        sentences,
    required TResult Function(_FlutterTextCapitalizationwords value) words,
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
@JsonSerializable(createToJson: false)
class _$_FlutterTextCapitalizationcharacters
    extends _FlutterTextCapitalizationcharacters {
  _$_FlutterTextCapitalizationcharacters({final String? $type})
      : $type = $type ?? 'f:1:TextCapitalization.characters',
        super._();

  factory _$_FlutterTextCapitalizationcharacters.fromJson(
          Map<String, dynamic> json) =>
      _$$_FlutterTextCapitalizationcharactersFromJson(json);

  @JsonKey(name: '_converter')
  final String $type;

  @override
  String toString() {
    return 'FlutterTextCapitalization.characters()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FlutterTextCapitalizationcharacters);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterTextCapitalizationcharacters value)
        characters,
    required TResult Function(_FlutterTextCapitalizationnone value) none,
    required TResult Function(_FlutterTextCapitalizationsentences value)
        sentences,
    required TResult Function(_FlutterTextCapitalizationwords value) words,
  }) {
    return characters(this);
  }
}

abstract class _FlutterTextCapitalizationcharacters
    extends FlutterTextCapitalization {
  factory _FlutterTextCapitalizationcharacters() =
      _$_FlutterTextCapitalizationcharacters;
  _FlutterTextCapitalizationcharacters._() : super._();

  factory _FlutterTextCapitalizationcharacters.fromJson(
          Map<String, dynamic> json) =
      _$_FlutterTextCapitalizationcharacters.fromJson;
}

/// @nodoc
@JsonSerializable(createToJson: false)
class _$_FlutterTextCapitalizationnone extends _FlutterTextCapitalizationnone {
  _$_FlutterTextCapitalizationnone({final String? $type})
      : $type = $type ?? 'f:1:TextCapitalization.none',
        super._();

  factory _$_FlutterTextCapitalizationnone.fromJson(
          Map<String, dynamic> json) =>
      _$$_FlutterTextCapitalizationnoneFromJson(json);

  @JsonKey(name: '_converter')
  final String $type;

  @override
  String toString() {
    return 'FlutterTextCapitalization.none()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FlutterTextCapitalizationnone);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterTextCapitalizationcharacters value)
        characters,
    required TResult Function(_FlutterTextCapitalizationnone value) none,
    required TResult Function(_FlutterTextCapitalizationsentences value)
        sentences,
    required TResult Function(_FlutterTextCapitalizationwords value) words,
  }) {
    return none(this);
  }
}

abstract class _FlutterTextCapitalizationnone
    extends FlutterTextCapitalization {
  factory _FlutterTextCapitalizationnone() = _$_FlutterTextCapitalizationnone;
  _FlutterTextCapitalizationnone._() : super._();

  factory _FlutterTextCapitalizationnone.fromJson(Map<String, dynamic> json) =
      _$_FlutterTextCapitalizationnone.fromJson;
}

/// @nodoc
@JsonSerializable(createToJson: false)
class _$_FlutterTextCapitalizationsentences
    extends _FlutterTextCapitalizationsentences {
  _$_FlutterTextCapitalizationsentences({final String? $type})
      : $type = $type ?? 'f:1:TextCapitalization.sentences',
        super._();

  factory _$_FlutterTextCapitalizationsentences.fromJson(
          Map<String, dynamic> json) =>
      _$$_FlutterTextCapitalizationsentencesFromJson(json);

  @JsonKey(name: '_converter')
  final String $type;

  @override
  String toString() {
    return 'FlutterTextCapitalization.sentences()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FlutterTextCapitalizationsentences);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterTextCapitalizationcharacters value)
        characters,
    required TResult Function(_FlutterTextCapitalizationnone value) none,
    required TResult Function(_FlutterTextCapitalizationsentences value)
        sentences,
    required TResult Function(_FlutterTextCapitalizationwords value) words,
  }) {
    return sentences(this);
  }
}

abstract class _FlutterTextCapitalizationsentences
    extends FlutterTextCapitalization {
  factory _FlutterTextCapitalizationsentences() =
      _$_FlutterTextCapitalizationsentences;
  _FlutterTextCapitalizationsentences._() : super._();

  factory _FlutterTextCapitalizationsentences.fromJson(
          Map<String, dynamic> json) =
      _$_FlutterTextCapitalizationsentences.fromJson;
}

/// @nodoc
@JsonSerializable(createToJson: false)
class _$_FlutterTextCapitalizationwords
    extends _FlutterTextCapitalizationwords {
  _$_FlutterTextCapitalizationwords({final String? $type})
      : $type = $type ?? 'f:1:TextCapitalization.words',
        super._();

  factory _$_FlutterTextCapitalizationwords.fromJson(
          Map<String, dynamic> json) =>
      _$$_FlutterTextCapitalizationwordsFromJson(json);

  @JsonKey(name: '_converter')
  final String $type;

  @override
  String toString() {
    return 'FlutterTextCapitalization.words()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FlutterTextCapitalizationwords);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterTextCapitalizationcharacters value)
        characters,
    required TResult Function(_FlutterTextCapitalizationnone value) none,
    required TResult Function(_FlutterTextCapitalizationsentences value)
        sentences,
    required TResult Function(_FlutterTextCapitalizationwords value) words,
  }) {
    return words(this);
  }
}

abstract class _FlutterTextCapitalizationwords
    extends FlutterTextCapitalization {
  factory _FlutterTextCapitalizationwords() = _$_FlutterTextCapitalizationwords;
  _FlutterTextCapitalizationwords._() : super._();

  factory _FlutterTextCapitalizationwords.fromJson(Map<String, dynamic> json) =
      _$_FlutterTextCapitalizationwords.fromJson;
}

FlutterSmartDashesType _$FlutterSmartDashesTypeFromJson(
    Map<String, dynamic> json) {
  switch (json['_converter']) {
    case 'f:1:SmartDashesType.disabled':
      return _FlutterSmartDashesTypedisabled.fromJson(json);
    case 'f:1:SmartDashesType.enabled':
      return _FlutterSmartDashesTypeenabled.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          '_converter',
          'FlutterSmartDashesType',
          'Invalid union type "${json['_converter']}"!');
  }
}

/// @nodoc
mixin _$FlutterSmartDashesType {
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterSmartDashesTypedisabled value) disabled,
    required TResult Function(_FlutterSmartDashesTypeenabled value) enabled,
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
@JsonSerializable(createToJson: false)
class _$_FlutterSmartDashesTypedisabled
    extends _FlutterSmartDashesTypedisabled {
  _$_FlutterSmartDashesTypedisabled({final String? $type})
      : $type = $type ?? 'f:1:SmartDashesType.disabled',
        super._();

  factory _$_FlutterSmartDashesTypedisabled.fromJson(
          Map<String, dynamic> json) =>
      _$$_FlutterSmartDashesTypedisabledFromJson(json);

  @JsonKey(name: '_converter')
  final String $type;

  @override
  String toString() {
    return 'FlutterSmartDashesType.disabled()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FlutterSmartDashesTypedisabled);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterSmartDashesTypedisabled value) disabled,
    required TResult Function(_FlutterSmartDashesTypeenabled value) enabled,
  }) {
    return disabled(this);
  }
}

abstract class _FlutterSmartDashesTypedisabled extends FlutterSmartDashesType {
  factory _FlutterSmartDashesTypedisabled() = _$_FlutterSmartDashesTypedisabled;
  _FlutterSmartDashesTypedisabled._() : super._();

  factory _FlutterSmartDashesTypedisabled.fromJson(Map<String, dynamic> json) =
      _$_FlutterSmartDashesTypedisabled.fromJson;
}

/// @nodoc
@JsonSerializable(createToJson: false)
class _$_FlutterSmartDashesTypeenabled extends _FlutterSmartDashesTypeenabled {
  _$_FlutterSmartDashesTypeenabled({final String? $type})
      : $type = $type ?? 'f:1:SmartDashesType.enabled',
        super._();

  factory _$_FlutterSmartDashesTypeenabled.fromJson(
          Map<String, dynamic> json) =>
      _$$_FlutterSmartDashesTypeenabledFromJson(json);

  @JsonKey(name: '_converter')
  final String $type;

  @override
  String toString() {
    return 'FlutterSmartDashesType.enabled()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FlutterSmartDashesTypeenabled);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterSmartDashesTypedisabled value) disabled,
    required TResult Function(_FlutterSmartDashesTypeenabled value) enabled,
  }) {
    return enabled(this);
  }
}

abstract class _FlutterSmartDashesTypeenabled extends FlutterSmartDashesType {
  factory _FlutterSmartDashesTypeenabled() = _$_FlutterSmartDashesTypeenabled;
  _FlutterSmartDashesTypeenabled._() : super._();

  factory _FlutterSmartDashesTypeenabled.fromJson(Map<String, dynamic> json) =
      _$_FlutterSmartDashesTypeenabled.fromJson;
}

FlutterSmartQuotesType _$FlutterSmartQuotesTypeFromJson(
    Map<String, dynamic> json) {
  switch (json['_converter']) {
    case 'f:1:SmartQuotesType.disabled':
      return _FlutterSmartQuotesTypedisabled.fromJson(json);
    case 'f:1:SmartQuotesType.enabled':
      return _FlutterSmartQuotesTypeenabled.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          '_converter',
          'FlutterSmartQuotesType',
          'Invalid union type "${json['_converter']}"!');
  }
}

/// @nodoc
mixin _$FlutterSmartQuotesType {
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterSmartQuotesTypedisabled value) disabled,
    required TResult Function(_FlutterSmartQuotesTypeenabled value) enabled,
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
@JsonSerializable(createToJson: false)
class _$_FlutterSmartQuotesTypedisabled
    extends _FlutterSmartQuotesTypedisabled {
  _$_FlutterSmartQuotesTypedisabled({final String? $type})
      : $type = $type ?? 'f:1:SmartQuotesType.disabled',
        super._();

  factory _$_FlutterSmartQuotesTypedisabled.fromJson(
          Map<String, dynamic> json) =>
      _$$_FlutterSmartQuotesTypedisabledFromJson(json);

  @JsonKey(name: '_converter')
  final String $type;

  @override
  String toString() {
    return 'FlutterSmartQuotesType.disabled()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FlutterSmartQuotesTypedisabled);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterSmartQuotesTypedisabled value) disabled,
    required TResult Function(_FlutterSmartQuotesTypeenabled value) enabled,
  }) {
    return disabled(this);
  }
}

abstract class _FlutterSmartQuotesTypedisabled extends FlutterSmartQuotesType {
  factory _FlutterSmartQuotesTypedisabled() = _$_FlutterSmartQuotesTypedisabled;
  _FlutterSmartQuotesTypedisabled._() : super._();

  factory _FlutterSmartQuotesTypedisabled.fromJson(Map<String, dynamic> json) =
      _$_FlutterSmartQuotesTypedisabled.fromJson;
}

/// @nodoc
@JsonSerializable(createToJson: false)
class _$_FlutterSmartQuotesTypeenabled extends _FlutterSmartQuotesTypeenabled {
  _$_FlutterSmartQuotesTypeenabled({final String? $type})
      : $type = $type ?? 'f:1:SmartQuotesType.enabled',
        super._();

  factory _$_FlutterSmartQuotesTypeenabled.fromJson(
          Map<String, dynamic> json) =>
      _$$_FlutterSmartQuotesTypeenabledFromJson(json);

  @JsonKey(name: '_converter')
  final String $type;

  @override
  String toString() {
    return 'FlutterSmartQuotesType.enabled()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FlutterSmartQuotesTypeenabled);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FlutterSmartQuotesTypedisabled value) disabled,
    required TResult Function(_FlutterSmartQuotesTypeenabled value) enabled,
  }) {
    return enabled(this);
  }
}

abstract class _FlutterSmartQuotesTypeenabled extends FlutterSmartQuotesType {
  factory _FlutterSmartQuotesTypeenabled() = _$_FlutterSmartQuotesTypeenabled;
  _FlutterSmartQuotesTypeenabled._() : super._();

  factory _FlutterSmartQuotesTypeenabled.fromJson(Map<String, dynamic> json) =
      _$_FlutterSmartQuotesTypeenabled.fromJson;
}
